---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { supabase } from '../../lib/supabase';

// Force no-cache for real-time updates
Astro.response.headers.set('Cache-Control', 'no-cache, no-store, must-revalidate');
Astro.response.headers.set('Pragma', 'no-cache');
Astro.response.headers.set('Expires', '0');

const { id: conversationId } = Astro.params;

// Get session from cookies (server-side auth)
const accessToken = Astro.cookies.get('sb-access-token')?.value;
const refreshToken = Astro.cookies.get('sb-refresh-token')?.value;

let currentUser = null;
if (accessToken && refreshToken) {
  const { data } = await supabase.auth.setSession({
    access_token: accessToken,
    refresh_token: refreshToken,
  });
  currentUser = data.session?.user;
}

// Redirect if not logged in
if (!currentUser) {
  return Astro.redirect('/login');
}

// Get conversation participants with fallback approach and error handling
let allParticipants = null;
let isCurrentUserParticipant = false;
let hasParticipantError = false;

try {
  // Use fallback approach directly (skip the join query that's causing issues)
  console.log('Using fallback approach for participants to avoid join query issues');
  
  const { data: participants, error: participantsError } = await supabase
    .from('conversation_participants')
    .select('user_id')
    .eq('conversation_id', conversationId);

  if (participantsError) {
    console.error('Error getting participants:', participantsError.message);
    hasParticipantError = true;
  } else if (participants) {
    const participantPromises = participants.map(async (p) => {
      try {
        const { data: profile, error: profileError } = await supabase
          .from('profiles')
          .select('username, full_name, avatar_url')
          .eq('id', p.user_id)
          .single();
        
        if (profileError) {
          console.error('Error getting profile for user', p.user_id, ':', profileError.message);
          return {
            user_id: p.user_id,
            profiles: {
              username: 'Unknown User',
              full_name: 'Unknown User',
              avatar_url: null
            }
          };
        }
        
        return {
          user_id: p.user_id,
          profiles: profile
        };
      } catch (error) {
        console.error('Error processing participant:', error.message);
        return {
          user_id: p.user_id,
          profiles: {
            username: 'Unknown User',
            full_name: 'Unknown User',
            avatar_url: null
          }
        };
      }
    });

    allParticipants = await Promise.all(participantPromises);
  }
} catch (error) {
  console.error('Error getting participants:', error);
  hasParticipantError = true;
}

// Check if current user is actually a participant
if (allParticipants && !hasParticipantError) {
  isCurrentUserParticipant = allParticipants.some(p => p.user_id === currentUser.id);
}

// If we have database errors, show a helpful error page instead of redirecting
if (hasParticipantError || (!isCurrentUserParticipant && !hasParticipantError)) {
  if (hasParticipantError) {
    console.log('Database error - showing error page instead of redirecting');
  } else {
    console.log('User not participant. User ID:', currentUser.id, 'Participants:', allParticipants?.map(p => p.user_id));
  }
  // Don't redirect - show error page instead
}

// Find the other user (not current user) with error handling
const otherParticipant = allParticipants?.find(p => p.user_id !== currentUser.id);

let displayName = 'Unknown User';
let displayAvatar = 'https://api.dicebear.com/7.x/initials/svg?seed=Unknown';

if (otherParticipant?.profiles) {
  displayName = otherParticipant.profiles.full_name || otherParticipant.profiles.username || 'Unknown User';
  displayAvatar = otherParticipant.profiles.avatar_url || `https://api.dicebear.com/7.x/initials/svg?seed=${displayName}`;
}

// Get messages with sender profiles with error handling
let messages = [];
let hasMessageError = false;

try {
  // Use fallback approach to avoid join query issues
  const { data: simpleMessages, error: simpleError } = await supabase
    .from('messages')
    .select('*')
    .eq('conversation_id', conversationId)
    .order('created_at', { ascending: true });

  if (simpleError) {
    console.error('Error getting messages:', simpleError.message);
    hasMessageError = true;
  } else {
    // Get sender profiles separately for each message
    const messagesWithSenders = await Promise.all(
      (simpleMessages || []).map(async (msg) => {
        try {
          const { data: senderProfile, error: senderError } = await supabase
            .from('profiles')
            .select('username, full_name, avatar_url')
            .eq('id', msg.sender_id)
            .single();

          return {
            ...msg,
            sender: senderError ? null : senderProfile
          };
        } catch (error) {
          console.error('Error getting sender profile:', error);
          return {
            ...msg,
            sender: null
          };
        }
      })
    );

    messages = messagesWithSenders;
  }
} catch (error) {
  console.error('Error getting messages:', error.message);
  hasMessageError = true;
}
---

<BaseLayout title={`Chat with ${displayName}`}>
  
  {(hasParticipantError || hasMessageError || (!isCurrentUserParticipant && !hasParticipantError)) ? (
    <!-- Error State -->
    <div class="min-h-screen flex items-center justify-center px-4">
      <div class="max-w-md w-full text-center">
        <div class="w-16 h-16 bg-red-100 dark:bg-red-900/20 rounded-2xl flex items-center justify-center mx-auto mb-6 border border-red-200 dark:border-red-800">
          <svg class="w-8 h-8 text-red-600 dark:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
          </svg>
        </div>
        
        <h1 class="text-xl font-medium text-stone-800 dark:text-stone-200 mb-3">
          {hasParticipantError || hasMessageError ? 'Database Error' : 'Access Denied'}
        </h1>
        
        <p class="text-stone-600 dark:text-stone-400 mb-6 leading-relaxed">
          {hasParticipantError || hasMessageError 
            ? 'There was an error accessing the conversation database. Please check your database configuration.'
            : 'You don\'t have access to this conversation or it doesn\'t exist.'
          }
        </p>
        
        <div class="space-y-3">
          <a href="/inbox" class="btn-primary block">
            Back to Inbox
          </a>
          
          {(hasParticipantError || hasMessageError) && (
            <div class="space-y-2">
              <button 
                id="fix-access-btn"
                class="btn-secondary block w-full"
              >
                ðŸ”§ Fix Access (Add Me to Conversation)
              </button>
              <a href="/system-status" class="btn-secondary block">
                Check System Status
              </a>
            </div>
          )}
        </div>
      </div>
    </div>
  ) : (
  <div class="flex flex-col h-[calc(100vh-64px)] md:h-[calc(100vh-80px)] relative">
    
    <!-- Header -->
    <div class="sticky top-0 z-20 px-6 py-4 bg-stone-50/95 dark:bg-stone-900/95 backdrop-blur-md border-b border-stone-200 dark:border-stone-700 flex items-center justify-between">
      <div class="flex items-center gap-4">
        <!-- Back Button (Mobile) -->
        <a 
          href="/inbox" 
          class="p-2 -ml-2 rounded-xl hover:bg-stone-200 dark:hover:bg-stone-800 text-stone-500 dark:text-stone-400 transition-colors md:hidden"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        </a>
        
        <!-- User Avatar -->
        <div class="relative">
          <img 
            src={displayAvatar} 
            alt={displayName} 
            class="w-10 h-10 md:w-12 md:h-12 rounded-xl object-cover border border-stone-300 dark:border-stone-600" 
          />
          <div class="absolute bottom-0 right-0 w-3 h-3 bg-green-500 border-2 border-stone-50 dark:border-stone-900 rounded-full"></div>
        </div>
        
        <!-- User Info -->
        <div>
          <h1 class="text-base md:text-lg font-medium text-stone-800 dark:text-stone-200 leading-tight">
            {displayName}
          </h1>
          <p class="text-xs text-stone-600 dark:text-stone-400 font-normal flex items-center gap-1">
            <span class="w-1.5 h-1.5 rounded-full bg-green-500 inline-block"></span> 
            Online now
          </p>
        </div>
      </div>

      <!-- Options Menu -->
      <button class="p-2 rounded-xl text-stone-400 hover:text-stone-800 dark:hover:text-stone-200 hover:bg-stone-200 dark:hover:bg-stone-800 transition-colors">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z" />
        </svg>
      </button>
    </div>

    <!-- Messages Container -->
    <div 
      id="messages-container" 
      class="flex-1 overflow-y-auto px-6 py-6 space-y-4 scroll-smooth"
    >
      
      <!-- Date Divider -->
      <div class="flex justify-center">
        <span class="text-xs font-medium text-stone-500 dark:text-stone-400 bg-stone-100 dark:bg-stone-800 px-3 py-1 rounded-xl border border-stone-200 dark:border-stone-700">
          Today
        </span>
      </div>

      <!-- Messages -->
      {messages && messages.map((msg) => {
        const isMe = msg.sender_id === currentUser.id;
        const senderAvatar = msg.sender?.avatar_url || `https://api.dicebear.com/7.x/initials/svg?seed=${msg.sender?.username || 'user'}`;
        const displayContent = msg.is_encrypted ? '[ðŸ”’ Encrypted message - unlock your keys to read]' : msg.content;
        const isEncrypted = msg.is_encrypted || false;
        
        return (
          <div class={`flex w-full ${isMe ? 'justify-end' : 'justify-start'} animate-fade-in-up`} data-message-id={msg.id}>
            <div class={`flex max-w-[85%] md:max-w-[70%] gap-2 ${isMe ? 'flex-row-reverse' : 'flex-row'}`}>
              
              {!isMe && (
                <img 
                  src={senderAvatar} 
                  alt="Avatar" 
                  class="w-8 h-8 rounded-xl object-cover border border-stone-300 dark:border-stone-600 flex-shrink-0 mt-1" 
                />
              )}
              
              <!-- Message Bubble -->
              <div 
                class={`group relative px-4 md:px-5 py-3 text-sm md:text-base leading-relaxed break-words
                  ${isMe 
                    ? 'bg-stone-800 dark:bg-stone-200 text-stone-50 dark:text-stone-900 rounded-2xl rounded-tr-lg' 
                    : 'bg-stone-100 dark:bg-stone-800 border border-stone-200 dark:border-stone-700 text-stone-800 dark:text-stone-200 rounded-2xl rounded-tl-lg'
                  }`}
              >
                {isEncrypted && (
                  <div class="flex items-center gap-1 mb-1 opacity-60">
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                    </svg>
                    <span class="text-xs">Encrypted</span>
                  </div>
                )}
                <p class="whitespace-pre-wrap" data-encrypted={isEncrypted} data-message-content={msg.encrypted_content ? JSON.stringify(msg.encrypted_content) : ''}>{displayContent}</p>
                
                <!-- Timestamp (shows on hover) -->
                <span 
                  class={`text-xs absolute -bottom-5 min-w-max opacity-0 group-hover:opacity-100 transition-opacity duration-200 text-stone-500 dark:text-stone-400 ${isMe ? 'right-0' : 'left-0'}`}
                >
                  {new Date(msg.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                </span>
              </div>

            </div>
          </div>
        )
      })}

      <!-- Scroll anchor -->
      <div id="scroll-anchor"></div>
    </div>

    <!-- Message Input -->
    <div class="sticky bottom-0 p-4 bg-stone-50 dark:bg-stone-900 border-t border-stone-200 dark:border-stone-700">
      <form id="message-form" class="max-w-4xl mx-auto relative flex items-center gap-3">
        
        <!-- Image Upload Button -->
        <button 
          type="button" 
          class="p-3 text-stone-400 hover:text-stone-800 dark:hover:text-stone-200 hover:bg-stone-200 dark:hover:bg-stone-800 rounded-xl transition-colors"
          title="Attach image"
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
          </svg>
        </button>

        <!-- Text Input -->
        <input
          type="text"
          id="message-input"
          placeholder="Type a message..."
          autocomplete="off"
          class="input-field flex-1"
          required
        />

        <!-- Send Button -->
        <button
          type="submit"
          id="send-btn"
          class="btn-primary p-3 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
          </svg>
        </button>
      </form>
    </div>

  </div>
  )}
</BaseLayout>

<script define:vars={{ conversationId, currentUserId: currentUser?.id }}>
  // Fix access button functionality
  const fixAccessBtn = document.getElementById('fix-access-btn');
  if (fixAccessBtn) {
    fixAccessBtn.addEventListener('click', async () => {
      fixAccessBtn.disabled = true;
      fixAccessBtn.textContent = 'Fixing access...';
      
      try {
        const response = await fetch('/api/fix-conversation-participants', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          }
        });
        
        const data = await response.json();
        
        if (data.success) {
          // Reload the page to show the conversation
          window.location.reload();
        } else {
          alert('Failed to fix access: ' + (data.error || 'Unknown error'));
          fixAccessBtn.disabled = false;
          fixAccessBtn.textContent = 'ðŸ”§ Fix Access (Add Me to Conversation)';
        }
      } catch (error) {
        alert('Error fixing access: ' + error.message);
        fixAccessBtn.disabled = false;
        fixAccessBtn.textContent = 'ðŸ”§ Fix Access (Add Me to Conversation)';
      }
    });
  }

  // Import modules
  let supabase = null;
  let autoEncryption = null;
  
  // Initialize modules
  async function initializeModules() {
    try {
      const supabaseModule = await import('../../lib/supabase.js');
      supabase = supabaseModule.supabase;
    } catch (error) {
      console.error('Failed to load supabase:', error);
      return false;
    }
    
    try {
      const autoEncryptionModule = await import('../../lib/autoEncryption.js');
      autoEncryption = autoEncryptionModule.autoEncryption;
    } catch (error) {
      console.log('Auto encryption not available:', error.message);
    }
    
    return true;
  }

  // Initialize modules and start the app
  initializeModules().then((success) => {
    if (!success) {
      console.error('Failed to initialize required modules');
      // Still try to initialize basic functionality without encryption
      initializeChatBasic();
      return;
    }
    
    // Initialize the chat interface (encryption disabled for serverless compatibility)
    initializeChatBasic();
  });

  // Basic chat functionality without encryption
  function initializeChatBasic() {
    console.log('Initializing basic chat functionality...');
    
    const container = document.getElementById('messages-container');
    const form = document.getElementById('message-form');
    const input = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');

    // Scroll to bottom function
    function scrollToBottom(smooth = false) {
      if (container) {
        if (smooth) {
          container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
        } else {
          container.scrollTop = container.scrollHeight;
        }
      }
    }

    // Initial scroll to bottom
    setTimeout(() => scrollToBottom(), 100);

    // Mark messages as read when conversation is opened
    async function markConversationAsRead() {
      try {
        console.log('Marking conversation as read:', conversationId);
        const response = await fetch('/api/mark-messages-read', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            conversation_id: conversationId
          })
        });

        if (response.ok) {
          const result = await response.json();
          console.log('Messages marked as read:', result);
          
          // Update navbar unread count immediately
          if (window.updateNavbarUnreadCount) {
            setTimeout(() => window.updateNavbarUnreadCount(), 500);
          }
        } else {
          const errorText = await response.text();
          console.error('Failed to mark messages as read:', response.status, errorText);
        }
      } catch (error) {
        console.error('Error marking messages as read:', error);
      }
    }

    // Mark as read when page loads (with longer delay to ensure everything is loaded)
    setTimeout(() => markConversationAsRead(), 2000);

    // Mark as read when user becomes active (returns to tab)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        setTimeout(() => markConversationAsRead(), 1000);
      }
    });

    // Mark as read when user scrolls to bottom
    if (container) {
      container.addEventListener('scroll', () => {
        const isAtBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 50;
        if (isAtBottom) {
          setTimeout(() => markConversationAsRead(), 1000);
        }
      });
    }

    // Mark as read when user clicks anywhere in the conversation
    document.addEventListener('click', () => {
      setTimeout(() => markConversationAsRead(), 500);
    });

    // Basic message sending without encryption
    if (form && input) {
      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const content = input.value.trim();
        if (!content) return;

        // Disable input while sending
        sendBtn.disabled = true;
        input.disabled = true;
        
        // Clear input immediately for better UX
        const originalContent = content;
        input.value = '';

        try {
          const response = await fetch('/api/send-message', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              conversation_id: conversationId,
              content: content
            })
          });

          let responseData;
          try {
            responseData = await response.json();
          } catch (jsonError) {
            // If response is not JSON, get text instead
            const responseText = await response.text();
            console.error('Non-JSON response:', responseText);
            throw new Error(`Server returned non-JSON response: ${responseText.substring(0, 100)}...`);
          }

          if (!response.ok) {
            throw new Error(responseData.error || 'Failed to send message');
          }

          // Add message to UI immediately (optimistic update)
          const messageEl = document.createElement('div');
          messageEl.className = 'flex w-full justify-end animate-fade-in-up';
          messageEl.innerHTML = `
            <div class="flex max-w-[85%] md:max-w-[70%] gap-2 flex-row-reverse">
              <div class="group relative px-4 md:px-5 py-2.5 md:py-3 shadow-sm text-sm md:text-base leading-relaxed break-words bg-neutral-900 dark:bg-white text-white dark:text-black rounded-2xl rounded-tr-md">
                <p class="whitespace-pre-wrap">${escapeHtml(originalContent)}</p>
                <span class="text-[10px] absolute -bottom-5 min-w-max opacity-0 group-hover:opacity-100 transition-opacity duration-200 text-neutral-400 dark:text-neutral-500 right-0">
                  Just now
                </span>
              </div>
            </div>
          `;
          container.appendChild(messageEl);
          scrollToBottom(true);
          
        } catch (err) {
          console.error('Error sending message:', err);
          alert('Failed to send message: ' + err.message);
          input.value = originalContent; // Restore message on error
        } finally {
          // Re-enable input
          sendBtn.disabled = false;
          input.disabled = false;
          input.focus();
        }
      });
    }

    // Auto-focus input
    if (input) {
      input.focus();
    }

    // Simple HTML escape function
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Real-time updates for new messages from others
    if (window.supabase) {
      window.supabase
        .channel(`conversation_${conversationId}`)
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: `conversation_id=eq.${conversationId}`
        }, async (payload) => {
          console.log('Real-time message received:', payload);
          
          const newMessage = payload.new;
          
          // Only add if it's from another user and not already displayed
          if (newMessage.sender_id !== currentUserId) {
            const existingMsg = container.querySelector(`[data-message-id="${newMessage.id}"]`);
            if (!existingMsg) {
              // Add the new message to UI
              const messageEl = document.createElement('div');
              messageEl.className = 'flex w-full justify-start animate-fade-in-up';
              messageEl.setAttribute('data-message-id', newMessage.id);
              messageEl.innerHTML = `
                <div class="flex max-w-[85%] md:max-w-[70%] gap-2 flex-row">
                  <img src="https://api.dicebear.com/7.x/initials/svg?seed=user" alt="Avatar" class="w-8 h-8 rounded-full object-cover border border-neutral-200 dark:border-neutral-700 flex-shrink-0 mt-1" />
                  <div class="group relative px-4 md:px-5 py-2.5 md:py-3 shadow-sm text-sm md:text-base leading-relaxed break-words bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-white rounded-2xl rounded-tl-md">
                    <p class="whitespace-pre-wrap">${escapeHtml(newMessage.content)}</p>
                    <span class="text-[10px] absolute -bottom-5 min-w-max opacity-0 group-hover:opacity-100 transition-opacity duration-200 text-neutral-400 dark:text-neutral-500 left-0">
                      ${new Date(newMessage.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                    </span>
                  </div>
                </div>
              `;
              container.appendChild(messageEl);
              scrollToBottom(true);
              
              // Play notification sound
              try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
              } catch (error) {
                console.log('Could not play notification sound:', error);
              }
              
              // Mark as read after a short delay if user is viewing the conversation
              if (document.visibilityState === 'visible') {
                setTimeout(() => markConversationAsRead(), 1000);
              }
            }
          }
        })
        .subscribe();
    }
  }

  function initializeChat() {
    const container = document.getElementById('messages-container');
    const form = document.getElementById('message-form');
    const input = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');

    // Initialize automatic encryption for current user
    async function initializeAutoEncryption() {
      if (autoEncryption && currentUserId) {
        try {
          console.log('Initializing automatic encryption for user:', currentUserId);
          const success = await autoEncryption.initializeForUser(currentUserId);
          if (success) {
            console.log('Automatic encryption initialized successfully');
          } else {
            console.log('Failed to initialize automatic encryption');
          }
        } catch (error) {
          console.error('Error initializing automatic encryption:', error);
        }
      }
    }

    // Initialize encryption on page load
    initializeAutoEncryption();

    // Scroll to bottom function
    function scrollToBottom(smooth = false) {
      if (container) {
        if (smooth) {
          container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
        } else {
          container.scrollTop = container.scrollHeight;
        }
      }
    }

    // Initial scroll to bottom
    setTimeout(() => scrollToBottom(), 100);

    // Decrypt existing encrypted messages on page load
    async function decryptExistingMessages() {
      try {
        if (!autoEncryption || !autoEncryption.isReady()) return;

        const encryptedMessages = container.querySelectorAll('[data-encrypted="true"]');
        
        for (const messageEl of encryptedMessages) {
          try {
            const encryptedData = messageEl.getAttribute('data-message-content');
            if (encryptedData) {
              const parsedData = JSON.parse(encryptedData);
              const decryptedContent = await autoEncryption.decryptMessage(parsedData);
              messageEl.textContent = decryptedContent;
              messageEl.removeAttribute('data-encrypted');
              messageEl.removeAttribute('data-message-content');
            }
          } catch (error) {
            console.error('Error decrypting existing message:', error);
            messageEl.textContent = '[ðŸ”’ Failed to decrypt message]';
          }
        }
      } catch (error) {
        console.log('Encryption not available for existing messages:', error.message);
      }
    }

    // Try to decrypt messages after a short delay (to allow auto encryption to initialize)
    setTimeout(decryptExistingMessages, 2000);

    // Decrypt message if encrypted
    async function decryptMessageContent(message) {
      if (!message.is_encrypted || !message.encrypted_content) {
        return message.content;
      }

      try {
        if (!autoEncryption || !autoEncryption.isReady()) {
          return '[ðŸ”’ Encrypted message - initializing encryption...]';
        }

        const decryptedContent = await autoEncryption.decryptMessage(message.encrypted_content);
        return decryptedContent;
      } catch (error) {
        console.error('Error decrypting message:', error);
        return '[ðŸ”’ Failed to decrypt message]';
      }
    }

  // Create message element
  async function createMessageElement(text, isMe, timestamp = 'Just now', messageId = null, senderAvatar = null, isEncrypted = false) {
    const div = document.createElement('div');
    div.className = 'flex w-full ' + (isMe ? 'justify-end' : 'justify-start') + ' animate-fade-in-up';
    if (messageId) {
      div.setAttribute('data-message-id', messageId);
    }
    
    const avatarHtml = !isMe && senderAvatar ? 
      `<img src="${senderAvatar}" alt="Avatar" class="w-8 h-8 rounded-full object-cover border border-neutral-200 dark:border-neutral-700 flex-shrink-0 mt-1" />` : '';
    
    // Add encryption indicator
    const encryptionIndicator = isEncrypted ? 
      '<div class="flex items-center gap-1 mb-1 opacity-60"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" /></svg><span class="text-xs">Encrypted</span></div>' : '';
    
    div.innerHTML = 
      '<div class="flex max-w-[85%] md:max-w-[70%] gap-2 ' + (isMe ? 'flex-row-reverse' : 'flex-row') + '">' +
        avatarHtml +
        '<div class="group relative px-4 md:px-5 py-2.5 md:py-3 shadow-sm text-sm md:text-base leading-relaxed break-words ' +
          (isMe 
            ? 'bg-neutral-900 dark:bg-white text-white dark:text-black rounded-2xl rounded-tr-md' 
            : 'bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-white rounded-2xl rounded-tl-md'
          ) + '">' +
          encryptionIndicator +
          '<p class="whitespace-pre-wrap">' + escapeHtml(text) + '</p>' +
          '<span class="text-[10px] absolute -bottom-5 min-w-max opacity-0 group-hover:opacity-100 transition-opacity duration-200 text-neutral-400 dark:text-neutral-500 ' + (isMe ? 'right-0' : 'left-0') + '">' +
            timestamp +
          '</span>' +
        '</div>' +
      '</div>';
    return div;
  }

  // Escape HTML to prevent XSS
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Optimistic UI message sending
  if (form && input) {
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const content = input.value.trim();
      if (!content) return;

      // Disable input while sending
      sendBtn.disabled = true;
      input.disabled = true;
      
      // Clear input immediately
      input.value = '';

      // Check if encryption is available and enabled
      let shouldEncrypt = false;
      let otherParticipantId = null;
      
      try {
        if (autoEncryption && autoEncryption.isReady()) {
          // Get other participant's user ID for encryption
          const { data: participants } = await supabase
            .from('conversation_participants')
            .select('user_id')
            .eq('conversation_id', conversationId)
            .neq('user_id', currentUserId);
          
          if (participants && participants.length > 0) {
            otherParticipantId = participants[0].user_id;
            shouldEncrypt = true;
          }
        }
      } catch (e) {
        console.log('Encryption not available:', e.message);
      }
      
      let requestBody = {
        conversation_id: conversationId,
        content: content
      };

      if (shouldEncrypt && otherParticipantId) {
        try {
          // Encrypt the message
          const encryptedData = await autoEncryption.encryptMessageForUser(content, otherParticipantId);
          
          requestBody = {
            conversation_id: conversationId,
            content: content, // Keep original content for fallback
            encrypted_content: encryptedData
          };
        } catch (encryptError) {
          console.error('Encryption failed, sending unencrypted:', encryptError);
          // Fall back to unencrypted if encryption fails
        }
      }

      // OPTIMISTIC UI: Add message immediately
      const optimisticMsg = await createMessageElement(content, true, 'Sending...', null, null, shouldEncrypt);
      optimisticMsg.classList.add('optimistic-message');
      container.appendChild(optimisticMsg);
      scrollToBottom(true);

      try {
        console.log('Sending message to API...');
        const response = await fetch('/api/send-message', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody)
        });

        let responseData;
        try {
          responseData = await response.json();
        } catch (jsonError) {
          // If response is not JSON, get text instead
          const responseText = await response.text();
          throw new Error(`Server error: ${responseText}`);
        }

        if (!response.ok) {
          throw new Error(responseData.error || 'Failed to send message');
        }

        // Update optimistic message with real data
        optimisticMsg.classList.remove('optimistic-message');
        optimisticMsg.setAttribute('data-message-id', responseData.message?.id || 'temp-id');
        const timestampSpan = optimisticMsg.querySelector('span');
        if (timestampSpan) {
          timestampSpan.textContent = 'Just now';
        }
        
        console.log('Message sent successfully');
        
      } catch (err) {
        console.error('Error sending message:', err);
        // Remove optimistic message on error
        optimisticMsg.remove();
        alert('Failed to send message: ' + err.message);
        input.value = content; // Restore message on error
      } finally {
        // Re-enable input
        sendBtn.disabled = false;
        input.disabled = false;
        input.focus();
      }
    });
  }

  // Auto-focus input
  if (input) {
    input.focus();
  }

  // Mark messages as read when conversation is opened
  async function markConversationAsRead() {
    try {
      const response = await fetch('/api/mark-messages-read', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          conversation_id: conversationId
        })
      });

      if (response.ok) {
        console.log('Messages marked as read');
        
        // Update navbar unread count immediately
        if (window.updateNavbarUnreadCount) {
          setTimeout(() => window.updateNavbarUnreadCount(), 500);
        }
      }
    } catch (error) {
      console.log('Error marking messages as read:', error);
    }
  }

  // Mark as read when page loads
  setTimeout(() => markConversationAsRead(), 1000);

  // Mark as read when user becomes active (returns to tab)
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      setTimeout(() => markConversationAsRead(), 500);
    }
  });

  // Mark as read when user scrolls to bottom
  if (container) {
    container.addEventListener('scroll', () => {
      const isAtBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 10;
      if (isAtBottom) {
        setTimeout(() => markConversationAsRead(), 500);
      }
    });
  }

  // Handle window resize
  window.addEventListener('resize', () => {
    setTimeout(() => scrollToBottom(), 100);
  });

  // Notification sound function
  function playNotificationSound() {
    try {
      // Create a subtle notification sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
      
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.2);
    } catch (error) {
      console.log('Could not play notification sound:', error);
    }
  }

  // Real-time subscription for immediate updates
  supabase
    .channel(`conversation_${conversationId}`)
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'messages',
      filter: `conversation_id=eq.${conversationId}`
    }, async (payload) => {
      console.log('Real-time message received:', payload);
      
      const newMessage = payload.new;
      
      // Only add if it's from another user and not already displayed
      if (newMessage.sender_id !== currentUserId) {
        const existingMsg = container.querySelector(`[data-message-id="${newMessage.id}"]`);
        if (!existingMsg) {
          // Fetch sender profile for avatar
          const { data: senderProfile } = await supabase
            .from('profiles')
            .select('avatar_url, username')
            .eq('id', newMessage.sender_id)
            .single();
          
          const senderAvatar = senderProfile?.avatar_url || `https://api.dicebear.com/7.x/initials/svg?seed=${senderProfile?.username || 'user'}`;
          
          // Decrypt message content if encrypted
          const displayContent = await decryptMessageContent(newMessage);
          
          const msgEl = await createMessageElement(
            displayContent,
            false,
            new Date(newMessage.created_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
            newMessage.id,
            senderAvatar,
            newMessage.is_encrypted || false
          );
          container.appendChild(msgEl);
          scrollToBottom(true);
          playNotificationSound();
          
          // Mark as read after a short delay if user is viewing the conversation
          if (document.visibilityState === 'visible') {
            setTimeout(() => markConversationAsRead(), 2000);
          }
        }
      }
    })
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'message_reads'
    }, (payload) => {
      console.log('Message read status updated:', payload);
      // Update navbar unread count when messages are marked as read
      if (window.updateNavbarUnreadCount) {
        setTimeout(() => window.updateNavbarUnreadCount(), 500);
      }
    })
    .subscribe();
  } // End of initializeChat function
</script>

<style>
  /* Fade in animation for new messages */
  .animate-fade-in-up {
    animation: fadeInUp 0.3s ease-out forwards;
  }

  @keyframes fadeInUp {
    from { 
      opacity: 0; 
      transform: translateY(10px); 
    }
    to { 
      opacity: 1; 
      transform: translateY(0); 
    }
  }

  /* Optimistic message styling */
  .optimistic-message {
    opacity: 0.7;
  }

  /* Custom scrollbar */
  #messages-container::-webkit-scrollbar {
    width: 6px;
  }

  #messages-container::-webkit-scrollbar-track {
    background: transparent;
  }

  #messages-container::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
  }

  .dark #messages-container::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
  }

  #messages-container::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.3);
  }

  .dark #messages-container::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
  }
</style>