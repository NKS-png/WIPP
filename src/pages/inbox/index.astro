---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { supabase } from '../../lib/supabase';

// Get session from cookies
const accessToken = Astro.cookies.get('sb-access-token')?.value;
const refreshToken = Astro.cookies.get('sb-refresh-token')?.value;

let currentUser = null;
if (accessToken && refreshToken) {
  const { data } = await supabase.auth.setSession({
    access_token: accessToken,
    refresh_token: refreshToken,
  });
  currentUser = data.session?.user;
}

// Redirect if not logged in
if (!currentUser) {
  return Astro.redirect('/login');
}

// Get conversations using simplified approach with error handling
let myParticipations = null;
let conversationDetails = [];

try {
  const { data, error } = await supabase
    .from('conversation_participants')
    .select('conversation_id')
    .eq('user_id', currentUser.id);
  
  if (error) {
    console.error('Error getting participations:', error.message);
    // Continue with empty conversations - don't crash the page
  } else {
    myParticipations = data;
    console.log('My participations:', myParticipations);
  }
} catch (error) {
  console.error('Database error getting participations:', error.message);
  // Continue with empty conversations - don't crash the page
}

if (myParticipations && myParticipations.length > 0) {
  const conversationIds = myParticipations.map(p => p.conversation_id);
  
  try {
    // Get conversation details
    const { data: conversations, error: conversationsError } = await supabase
      .from('conversations')
      .select('*')
      .in('id', conversationIds)
      .order('updated_at', { ascending: false });

    if (conversationsError) {
      console.error('Error getting conversations:', conversationsError.message);
    } else {
      console.log('Conversations:', conversations);

      // Get unread counts per conversation (optional - fallback if function doesn't exist)
      let unreadCounts = null;
      try {
        const { data, error } = await supabase.rpc('get_conversation_unread_counts', {
          p_user_id: currentUser.id
        });
        
        if (error) {
          console.log('Unread counts RPC error:', error.message);
          unreadCounts = [];
        } else {
          unreadCounts = data;
          console.log('Unread counts:', unreadCounts);
        }
      } catch (error) {
        console.log('Unread counts function not available (message-read-tracking.sql not run):', error.message);
        // Fallback: assume no unread counts
        unreadCounts = [];
      }

      // Create a map for quick lookup
      const unreadMap = new Map();
      if (unreadCounts) {
        unreadCounts.forEach(item => {
          unreadMap.set(item.conversation_id, item.unread_count);
        });
      }

      // Get details for each conversation with error handling
      const conversationPromises = (conversations || []).map(async (conv) => {
        try {
          // First, check if this conversation has any messages
          const { count: messageCount, error: messageCountError } = await supabase
            .from('messages')
            .select('*', { count: 'exact', head: true })
            .eq('conversation_id', conv.id);

          if (messageCountError) {
            console.error('Error getting message count for conversation', conv.id, ':', messageCountError.message);
            return null;
          }

          // Skip conversations with no messages
          if (!messageCount || messageCount === 0) {
            return null;
          }

          // Get other participant with error handling
          const { data: otherParticipants, error: participantsError } = await supabase
            .from('conversation_participants')
            .select('user_id')
            .eq('conversation_id', conv.id)
            .neq('user_id', currentUser.id);

          if (participantsError) {
            console.error('Error getting participants for conversation', conv.id, ':', participantsError.message);
            return null;
          }

          let partner = null;
          if (otherParticipants && otherParticipants.length > 0) {
            try {
              const { data: partnerProfile, error: profileError } = await supabase
                .from('profiles')
                .select('id, username, full_name, avatar_url')
                .eq('id', otherParticipants[0].user_id)
                .single();
              
              if (profileError) {
                console.error('Error getting partner profile:', profileError.message);
                // Create a fallback partner object
                partner = {
                  id: otherParticipants[0].user_id,
                  username: 'Unknown User',
                  full_name: 'Unknown User',
                  avatar_url: null
                };
              } else {
                partner = partnerProfile;
              }
            } catch (profileError) {
              console.error('Error getting partner profile:', profileError.message);
              // Create a fallback partner object
              partner = {
                id: otherParticipants[0].user_id,
                username: 'Unknown User',
                full_name: 'Unknown User',
                avatar_url: null
              };
            }
          }

          // Get last message with error handling
          let lastMessage = null;
          try {
            const { data, error: lastMessageError } = await supabase
              .from('messages')
              .select('*')
              .eq('conversation_id', conv.id)
              .order('created_at', { ascending: false })
              .limit(1)
              .single();

            if (lastMessageError) {
              console.error('Error getting last message for conversation', conv.id, ':', lastMessageError.message);
            } else {
              lastMessage = data;
            }
          } catch (lastMessageError) {
            console.error('Error getting last message:', lastMessageError.message);
          }

          // Get unread count from our map
          const unreadCount = unreadMap.get(conv.id) || 0;

          return {
            id: conv.id,
            partner: partner,
            lastMessage: lastMessage,
            unreadCount: parseInt(unreadCount),
            updatedAt: conv.updated_at || conv.created_at,
            messageCount: messageCount
          };
        } catch (error) {
          console.error('Error processing conversation', conv.id, ':', error.message);
          return null;
        }
      });

      conversationDetails = await Promise.all(conversationPromises);

      // Filter out null results (conversations with errors, no messages, or no valid partners)
      conversationDetails = conversationDetails.filter(c => c !== null && c.partner);
    }
  } catch (error) {
    console.error('Error processing conversations:', error.message);
    // Continue with empty conversations - don't crash the page
  }
}

// Filter conversations and sort by most recent
const sortedConversations = conversationDetails
  .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());

console.log('Final conversations (with messages only):', sortedConversations);

// Check if we have database issues
const hasDatabaseIssues = myParticipations === null;
const hasConversations = sortedConversations.length > 0;
---

<BaseLayout title="Inbox">
  <div class="min-h-screen">
    <div class="max-w-4xl mx-auto px-6 py-8">
      
      <!-- Header -->
      <div class="mb-8">
        <h1 class="text-3xl font-normal text-stone-800 dark:text-stone-200 mb-2 font-serif">
          Messages
        </h1>
        <p class="text-stone-600 dark:text-stone-400 font-normal">
          {sortedConversations.length} conversation{sortedConversations.length !== 1 ? 's' : ''}
        </p>
        
        {hasDatabaseIssues && (
          <div class="mt-4 p-6 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-2xl">
            <div class="flex items-center gap-3 mb-3">
              <svg class="w-5 h-5 text-amber-600 dark:text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
              </svg>
              <span class="font-medium text-amber-800 dark:text-amber-200">Database Setup Required</span>
            </div>
            <p class="text-sm text-amber-700 dark:text-amber-300 mb-4 leading-relaxed">
              Your database needs to be configured for messaging. Please run the required SQL migrations.
            </p>
            <div class="flex gap-3">
              <a href="/system-status" class="btn-primary text-sm">
                Check System Status
              </a>
            </div>
          </div>
        )}
      </div>

      <!-- Search & Filter Bar -->
      <div class="mb-8 flex items-center gap-4">
        <div class="flex-1 relative">
          <input
            type="text"
            id="search-input"
            placeholder="Search conversations..."
            class="input-field pl-12"
          />
          <svg class="w-5 h-5 absolute left-4 top-1/2 -translate-y-1/2 text-stone-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </div>
        
        <button 
          onclick="window.location.reload()" 
          class="btn-secondary flex items-center gap-2"
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
          <span class="hidden md:inline">Refresh</span>
        </button>
        
        <button 
          id="new-message-btn"
          class="btn-primary flex items-center gap-2"
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
          </svg>
          <span class="hidden md:inline">New Message</span>
        </button>
      </div>

      <!-- Conversations List -->
      <div class="space-y-4" id="conversations-list">
        {sortedConversations.length > 0 ? (
          sortedConversations.map((conv) => {
            const partner = conv.partner;
            const displayName = partner?.full_name || partner?.username || 'Unknown User';
            const displayAvatar = partner?.avatar_url || `https://api.dicebear.com/7.x/initials/svg?seed=${displayName}`;
            const lastMsg = conv.lastMessage;
            const isUnread = conv.unreadCount > 0;
            const isSentByMe = lastMsg?.sender_id === currentUser.id;

            return (
              <a
                href={`/inbox/${conv.id}`}
                class="block bg-stone-100 dark:bg-stone-800 border border-stone-200 dark:border-stone-700 rounded-2xl p-6 hover:border-stone-400 dark:hover:border-stone-500 transition-all hover:shadow-sm conversation-item"
                data-conversation-id={conv.id}
              >
                <div class="flex items-center gap-4">
                  <!-- Avatar -->
                  <div class="relative flex-shrink-0">
                    <img
                      src={displayAvatar}
                      alt={displayName}
                      class="w-12 h-12 rounded-xl object-cover border border-stone-300 dark:border-stone-600"
                    />
                    {isUnread && (
                      <div class="absolute -top-1 -right-1 w-5 h-5 bg-red-500 border-2 border-stone-100 dark:border-stone-800 rounded-full flex items-center justify-center notification-dot">
                        <span class="text-white text-xs font-medium">{conv.unreadCount > 99 ? '99+' : conv.unreadCount}</span>
                      </div>
                    )}
                  </div>

                  <!-- Content -->
                  <div class="flex-1 min-w-0">
                    <div class="flex items-center justify-between mb-1">
                      <h3 class={`font-medium text-stone-800 dark:text-stone-200 truncate ${isUnread ? 'font-semibold' : ''}`}>
                        {displayName}
                      </h3>
                      {lastMsg && (
                        <span class="text-xs text-stone-500 dark:text-stone-400 flex-shrink-0 ml-2">
                          {new Date(lastMsg.created_at).toLocaleDateString() === new Date().toLocaleDateString()
                            ? new Date(lastMsg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                            : new Date(lastMsg.created_at).toLocaleDateString([], { month: 'short', day: 'numeric' })
                          }
                        </span>
                      )}
                    </div>
                    
                    {lastMsg ? (
                      <p class={`text-sm truncate ${isUnread ? 'text-stone-700 dark:text-stone-300 font-medium' : 'text-stone-600 dark:text-stone-400'}`}>
                        {isSentByMe && <span class="text-stone-500 mr-1">You:</span>}
                        {lastMsg.content}
                      </p>
                    ) : (
                      <p class="text-sm text-stone-500 italic">No messages yet</p>
                    )}
                  </div>

                  <!-- Arrow Icon -->
                  <svg class="w-5 h-5 text-stone-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                  </svg>
                </div>
              </a>
            );
          })
        ) : (
          <!-- Empty State -->
          <div class="bg-stone-100 dark:bg-stone-800 border border-stone-200 dark:border-stone-700 rounded-2xl p-16 text-center">
            <div class="w-16 h-16 bg-stone-300 dark:bg-stone-600 rounded-2xl flex items-center justify-center mx-auto mb-6">
              <svg class="w-8 h-8 text-stone-600 dark:text-stone-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
              </svg>
            </div>
            <h3 class="text-xl font-medium text-stone-800 dark:text-stone-200 mb-3">
              {hasDatabaseIssues ? 'Database Setup Required' : 'No messages yet'}
            </h3>
            <p class="text-stone-600 dark:text-stone-400 mb-6 max-w-md mx-auto leading-relaxed">
              {hasDatabaseIssues 
                ? 'Your messaging database needs to be configured. Please run the required SQL migrations to enable messaging.'
                : 'Start a conversation by visiting a user\'s profile and clicking "Message"'
              }
            </p>
            {hasDatabaseIssues ? (
              <div class="space-x-3">
                <a href="/system-status" class="btn-primary">
                  Check System Status
                </a>
              </div>
            ) : (
              <a href="/explore" class="btn-primary">
                Explore WIPP
              </a>
            )}
          </div>
        )}
      </div>

    </div>
  </div>

  <!-- New Message Modal -->
  <div id="new-message-modal" class="fixed inset-0 z-50 hidden flex items-center justify-center px-4 bg-black/40 backdrop-blur-sm">
    <div class="bg-stone-50 dark:bg-stone-900 w-full max-w-md rounded-2xl shadow-xl border border-stone-200 dark:border-stone-700 p-6 animate-fade-in-up">
      <div class="flex items-center justify-between mb-6">
        <h2 class="text-xl font-medium text-stone-800 dark:text-stone-200">New Message</h2>
        <button id="close-modal-btn" class="p-2 rounded-xl hover:bg-stone-200 dark:hover:bg-stone-800 transition-colors">
          <svg class="w-5 h-5 text-stone-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      <!-- User Search -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-stone-700 dark:text-stone-300 mb-2">Send to:</label>
        <div class="relative">
          <input
            type="text"
            id="user-search-input"
            placeholder="Search users..."
            class="input-field"
            autocomplete="off"
          />
          
          <!-- Search Results -->
          <div id="user-search-results" class="absolute top-full left-0 right-0 mt-1 bg-stone-50 dark:bg-stone-800 border border-stone-200 dark:border-stone-700 rounded-xl shadow-lg max-h-60 overflow-y-auto hidden z-10">
            <div id="user-search-loading" class="hidden p-4 text-center text-stone-500">
              <div class="animate-spin w-4 h-4 border-2 border-stone-300 border-t-stone-600 rounded-full mx-auto mb-2"></div>
              Searching...
            </div>
            <div id="user-search-empty" class="hidden p-4 text-center text-stone-500 text-sm">
              No users found
            </div>
            <div id="user-search-list" class="py-2">
              <!-- Search results will be inserted here -->
            </div>
          </div>
        </div>
      </div>

      <!-- Selected User -->
      <div id="selected-user" class="hidden mb-4 p-4 bg-stone-100 dark:bg-stone-800 rounded-xl border border-stone-200 dark:border-stone-700">
        <div class="flex items-center gap-3">
          <img id="selected-user-avatar" class="w-10 h-10 rounded-xl object-cover border border-stone-300 dark:border-stone-600" />
          <div class="flex-1">
            <div id="selected-user-name" class="font-medium text-stone-800 dark:text-stone-200"></div>
            <div id="selected-user-username" class="text-sm text-stone-600 dark:text-stone-400"></div>
          </div>
          <button id="remove-selected-user" class="p-1 rounded-xl hover:bg-stone-200 dark:hover:bg-stone-700 transition-colors">
            <svg class="w-4 h-4 text-stone-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>

      <!-- Message Input -->
      <div class="mb-6">
        <label class="block text-sm font-medium text-stone-700 dark:text-stone-300 mb-2">Message:</label>
        <textarea
          id="message-input"
          rows="4"
          placeholder="Type your message..."
          class="input-field resize-none"
          required
        ></textarea>
      </div>

      <!-- Actions -->
      <div class="flex gap-3">
        <button id="cancel-message-btn" class="btn-secondary flex-1">
          Cancel
        </button>
        <button id="send-message-btn" class="btn-primary flex-1 disabled:opacity-50 disabled:cursor-not-allowed">
          Send Message
        </button>
      </div>
    </div>
  </div>
</BaseLayout>

<script>
  // Import modules
  let supabase = null;
  let autoEncryption = null;
  
  // Initialize modules
  async function initializeModules() {
    try {
      const supabaseModule = await import('../../lib/supabase.js');
      supabase = supabaseModule.supabase;
    } catch (error) {
      console.error('Failed to load supabase:', error);
      return false;
    }
    
    try {
      const autoEncryptionModule = await import('../../lib/autoEncryption.js');
      autoEncryption = autoEncryptionModule.autoEncryption;
    } catch (error) {
      console.log('Auto encryption not available:', error.message);
    }
    
    return true;
  }

  // Initialize modules and start the app
  initializeModules().then((success) => {
    if (!success) {
      console.error('Failed to initialize required modules');
      // Still try to initialize basic functionality
      initializeInboxBasic();
      return;
    }
    
    // Initialize the inbox interface (encryption disabled for serverless compatibility)
    initializeInboxBasic();
  });

  // Basic inbox functionality without encryption
  function initializeInboxBasic() {
    console.log('Initializing basic inbox functionality...');
    
    // Search functionality
    const searchInput = document.getElementById('search-input');
    const conversationItems = document.querySelectorAll('.conversation-item');

    if (searchInput) {
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        
        conversationItems.forEach((item) => {
          const text = item.textContent?.toLowerCase() || '';
          if (text.includes(query)) {
            item.style.display = 'block';
          } else {
            item.style.display = 'none';
          }
        });
      });
    }

    // Basic new message modal (simplified)
    const newMessageBtn = document.getElementById('new-message-btn');
    const newMessageModal = document.getElementById('new-message-modal');
    const closeModalBtn = document.getElementById('close-modal-btn');
    const cancelMessageBtn = document.getElementById('cancel-message-btn');
    const userSearchInput = document.getElementById('user-search-input');
    const userSearchResults = document.getElementById('user-search-results');
    const userSearchLoading = document.getElementById('user-search-loading');
    const userSearchEmpty = document.getElementById('user-search-empty');
    const userSearchList = document.getElementById('user-search-list');
    const selectedUser = document.getElementById('selected-user');
    const selectedUserAvatar = document.getElementById('selected-user-avatar');
    const selectedUserName = document.getElementById('selected-user-name');
    const selectedUserUsername = document.getElementById('selected-user-username');
    const removeSelectedUserBtn = document.getElementById('remove-selected-user');
    const messageInput = document.getElementById('message-input');
    const sendMessageBtn = document.getElementById('send-message-btn');

    let selectedUserId = null;
    let userSearchTimeout;

    // Open modal
    newMessageBtn?.addEventListener('click', () => {
      newMessageModal.classList.remove('hidden');
      userSearchInput?.focus();
    });

    // Close modal
    function closeModal() {
      newMessageModal.classList.add('hidden');
      resetModal();
    }

    closeModalBtn?.addEventListener('click', closeModal);
    cancelMessageBtn?.addEventListener('click', closeModal);

    // Reset modal state
    function resetModal() {
      if (userSearchInput) userSearchInput.value = '';
      if (messageInput) messageInput.value = '';
      selectedUserId = null;
      selectedUser?.classList.add('hidden');
      userSearchResults?.classList.add('hidden');
      if (userSearchList) userSearchList.innerHTML = '';
    }

    // User search functionality
    userSearchInput?.addEventListener('input', (e) => {
      const query = e.target.value.trim();
      
      clearTimeout(userSearchTimeout);
      
      if (query.length < 2) {
        userSearchResults?.classList.add('hidden');
        return;
      }
      
      userSearchTimeout = setTimeout(() => {
        performUserSearch(query);
      }, 300);
    });

    // Also show results when focusing on the input
    userSearchInput?.addEventListener('focus', () => {
      if (userSearchInput.value.trim().length >= 2) {
        userSearchResults?.classList.remove('hidden');
      }
    });

    // Hide search results when clicking outside
    document.addEventListener('click', (e) => {
      if (!userSearchInput?.contains(e.target) && !userSearchResults?.contains(e.target)) {
        userSearchResults?.classList.add('hidden');
      }
    });

    async function performUserSearch(query) {
      console.log('Performing user search for:', query);
      
      if (!userSearchResults) {
        console.error('User search results element not found');
        return;
      }
      
      userSearchResults.classList.remove('hidden');
      userSearchLoading?.classList.remove('hidden');
      userSearchEmpty?.classList.add('hidden');
      if (userSearchList) userSearchList.innerHTML = '';

      try {
        console.log('Fetching users from API...');
        const response = await fetch(`/api/search-users?q=${encodeURIComponent(query)}`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('Search response:', data);

        userSearchLoading?.classList.add('hidden');

        if (data.users && data.users.length > 0) {
          console.log('Found', data.users.length, 'users');
          userSearchEmpty?.classList.add('hidden');
          
          data.users.forEach(user => {
            const userItem = document.createElement('button');
            userItem.type = 'button';
            userItem.className = 'w-full flex items-center gap-3 px-4 py-3 hover:bg-stone-100 dark:hover:bg-stone-700 transition-colors text-left rounded-lg mx-2';
            userItem.innerHTML = `
              <img src="${user.avatar}" alt="${user.displayName}" class="w-8 h-8 rounded-xl object-cover border border-stone-300 dark:border-stone-600" />
              <div class="flex-1 min-w-0">
                <div class="font-medium text-stone-800 dark:text-stone-200 truncate">${user.displayName}</div>
                <div class="text-xs text-stone-600 dark:text-stone-400 truncate">@${user.username}</div>
              </div>
            `;
            
            userItem.addEventListener('click', () => {
              selectUser(user);
            });
            
            if (userSearchList) userSearchList.appendChild(userItem);
          });
        } else {
          console.log('No users found');
          userSearchEmpty?.classList.remove('hidden');
        }
      } catch (error) {
        console.error('User search error:', error);
        userSearchLoading?.classList.add('hidden');
        userSearchEmpty?.classList.remove('hidden');
        if (userSearchEmpty) userSearchEmpty.textContent = 'Search failed. Please try again.';
      }
    }

    // Select user
    function selectUser(user) {
      selectedUserId = user.id;
      if (selectedUserAvatar) selectedUserAvatar.src = user.avatar;
      if (selectedUserName) selectedUserName.textContent = user.displayName;
      if (selectedUserUsername) selectedUserUsername.textContent = `@${user.username}`;
      
      selectedUser?.classList.remove('hidden');
      userSearchResults?.classList.add('hidden');
      if (userSearchInput) userSearchInput.value = '';
      messageInput?.focus();
    }

    // Remove selected user
    removeSelectedUserBtn?.addEventListener('click', () => {
      selectedUserId = null;
      selectedUser?.classList.add('hidden');
      userSearchInput?.focus();
    });

    // Send message (basic version without encryption)
    sendMessageBtn?.addEventListener('click', async () => {
      if (!selectedUserId || !messageInput?.value.trim()) {
        alert('Please select a user and enter a message.');
        return;
      }

      sendMessageBtn.disabled = true;
      sendMessageBtn.textContent = 'Sending...';

      try {
        const requestBody = {
          target_user_id: selectedUserId,
          initial_message: messageInput.value.trim()
        };

        const response = await fetch('/api/create-conversation', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody)
        });

        let data;
        try {
          data = await response.json();
        } catch (jsonError) {
          const responseText = await response.text();
          console.error('Non-JSON response:', responseText);
          throw new Error(`Server returned non-JSON response: ${responseText.substring(0, 100)}...`);
        }

        if (response.ok) {
          window.location.href = `/inbox/${data.conversation_id}`;
        } else {
          console.error('Create conversation API error:', {
            status: response.status,
            statusText: response.statusText,
            data: data
          });
          
          let errorMessage = data.error || 'Failed to create conversation';
          if (data.code) {
            errorMessage += ` (${data.code})`;
          }
          if (data.details) {
            console.error('Error details:', data.details);
            errorMessage += `\n\nDetails: ${data.details}`;
          }
          
          throw new Error(errorMessage);
        }
      } catch (error) {
        console.error('Error creating conversation:', error);
        alert('Failed to send message: ' + error.message);
        
        sendMessageBtn.disabled = false;
        sendMessageBtn.textContent = 'Send Message';
      }
    });

    // Close modal when clicking outside
    newMessageModal?.addEventListener('click', (e) => {
      if (e.target === newMessageModal) {
        closeModal();
      }
    });
  }

  function initializeInbox() {
    // Initialize automatic encryption for current user
    async function initializeAutoEncryption() {
      if (autoEncryption) {
        try {
          const { data: { session } } = await supabase.auth.getSession();
          if (session?.user?.id) {
            console.log('Initializing automatic encryption for user:', session.user.id);
            const success = await autoEncryption.initializeForUser(session.user.id);
            if (success) {
              console.log('Automatic encryption initialized successfully');
            } else {
              console.log('Failed to initialize automatic encryption');
            }
          }
        } catch (error) {
          console.error('Error initializing automatic encryption:', error);
        }
      }
    }

    // Initialize encryption on page load
    initializeAutoEncryption();

  // Search functionality
  const searchInput = document.getElementById('search-input');
  const conversationItems = document.querySelectorAll('.conversation-item');

  if (searchInput) {
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase();
      
      conversationItems.forEach((item) => {
        const text = item.textContent?.toLowerCase() || '';
        if (text.includes(query)) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });
    });
  }

  // Notification sound function
  function playNotificationSound() {
    try {
      // Create a subtle notification sound
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
      
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.2);
    } catch (error) {
      console.log('Could not play notification sound:', error);
    }
  }

  // Real-time updates for new messages and read status
  let lastMessageCount = conversationItems.length;
  
  async function updateUnreadCounts() {
    try {
      const response = await fetch('/api/conversation-unread-counts');
      if (response.ok) {
        const { counts } = await response.json();
        
        // Update unread badges for each conversation
        conversationItems.forEach(item => {
          const conversationId = item.getAttribute('data-conversation-id');
          const badge = item.querySelector('.notification-dot');
          const unreadCount = counts[conversationId] || 0;
          
          if (unreadCount > 0) {
            if (badge) {
              badge.textContent = unreadCount > 99 ? '99+' : unreadCount.toString();
              badge.classList.remove('hidden');
            }
          } else {
            if (badge) {
              badge.classList.add('hidden');
            }
          }
        });
      }
    } catch (error) {
      console.log('Error updating unread counts:', error);
    }
  }

  async function checkForNewMessages() {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) return;

      // Get current conversations count
      const { data: participations } = await supabase
        .from('conversation_participants')
        .select('conversation_id')
        .eq('user_id', session.user.id);

      if (!participations) return;

      const conversationIds = participations.map(p => p.conversation_id);
      
      // Check for new messages in the last 30 seconds
      const { data: recentMessages } = await supabase
        .from('messages')
        .select('conversation_id, sender_id, created_at')
        .in('conversation_id', conversationIds)
        .neq('sender_id', session.user.id)
        .gte('created_at', new Date(Date.now() - 30000).toISOString())
        .order('created_at', { ascending: false });

      if (recentMessages && recentMessages.length > 0) {
        // Play sound for new messages
        const lastCheck = localStorage.getItem('lastInboxCheck');
        const currentTime = Date.now();
        
        if (!lastCheck || (currentTime - parseInt(lastCheck)) > 30000) {
          playNotificationSound();
        }
        
        localStorage.setItem('lastInboxCheck', currentTime.toString());
        
        // Update unread counts instead of full refresh
        updateUnreadCounts();
        
        // Only refresh if there are significantly new messages
        setTimeout(() => {
          if (document.visibilityState === 'visible') {
            window.location.reload();
          }
        }, 5000);
      }
    } catch (error) {
      console.log('Error checking for new messages:', error);
    }
  }

  // Update unread counts every 10 seconds
  setInterval(updateUnreadCounts, 10000);

  // Check for new messages every 15 seconds
  setInterval(checkForNewMessages, 15000);

  // Real-time subscription for immediate updates
  supabase
    .channel('inbox_updates')
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'messages'
    }, (payload) => {
      console.log('New message received:', payload);
      playNotificationSound();
      
      // Show a subtle notification
      showNewMessageNotification();
      
      // Update unread counts
      updateUnreadCounts();
      
      // Refresh after a longer delay to allow for read status updates
      setTimeout(() => {
        if (document.visibilityState === 'visible') {
          window.location.reload();
        }
      }, 3000);
    })
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'message_reads'
    }, (payload) => {
      console.log('Message read status updated:', payload);
      // Update unread counts when messages are marked as read
      updateUnreadCounts();
    })
    .subscribe();

  // Show new message notification
  function showNewMessageNotification() {
    if (window.showNotification) {
      window.showNotification('New message received!', 'success', 3000);
    }
  }

  console.log('Inbox loaded with', conversationItems.length, 'conversations');

  // --- NEW MESSAGE MODAL FUNCTIONALITY ---
  const newMessageBtn = document.getElementById('new-message-btn');
  const newMessageModal = document.getElementById('new-message-modal');
  const closeModalBtn = document.getElementById('close-modal-btn');
  const cancelMessageBtn = document.getElementById('cancel-message-btn');
  const userSearchInput = document.getElementById('user-search-input');
  const userSearchResults = document.getElementById('user-search-results');
  const userSearchLoading = document.getElementById('user-search-loading');
  const userSearchEmpty = document.getElementById('user-search-empty');
  const userSearchList = document.getElementById('user-search-list');
  const selectedUser = document.getElementById('selected-user');
  const selectedUserAvatar = document.getElementById('selected-user-avatar');
  const selectedUserName = document.getElementById('selected-user-name');
  const selectedUserUsername = document.getElementById('selected-user-username');
  const removeSelectedUserBtn = document.getElementById('remove-selected-user');
  const messageInput = document.getElementById('message-input');
  const sendMessageBtn = document.getElementById('send-message-btn');

  let selectedUserId = null;
  let userSearchTimeout;

  // Open modal
  newMessageBtn?.addEventListener('click', () => {
    newMessageModal.classList.remove('hidden');
    userSearchInput.focus();
  });

  // Close modal
  function closeModal() {
    newMessageModal.classList.add('hidden');
    resetModal();
  }

  closeModalBtn?.addEventListener('click', closeModal);
  cancelMessageBtn?.addEventListener('click', closeModal);

  // Reset modal state
  function resetModal() {
    userSearchInput.value = '';
    messageInput.value = '';
    selectedUserId = null;
    selectedUser.classList.add('hidden');
    userSearchResults.classList.add('hidden');
    userSearchList.innerHTML = '';
  }

  // User search functionality
  userSearchInput?.addEventListener('input', (e) => {
    const query = e.target.value.trim();
    
    clearTimeout(userSearchTimeout);
    
    if (query.length < 2) {
      userSearchResults.classList.add('hidden');
      return;
    }
    
    userSearchTimeout = setTimeout(() => {
      performUserSearch(query);
    }, 300);
  });

  // Also show results when focusing on the input
  userSearchInput?.addEventListener('focus', () => {
    if (userSearchInput.value.trim().length >= 2) {
      userSearchResults.classList.remove('hidden');
    }
  });

  // Hide search results when clicking outside
  document.addEventListener('click', (e) => {
    if (!userSearchInput?.contains(e.target) && !userSearchResults?.contains(e.target)) {
      userSearchResults?.classList.add('hidden');
    }
  });

  async function performUserSearch(query) {
    console.log('Performing user search for:', query);
    
    if (!userSearchResults) {
      console.error('User search results element not found');
      return;
    }
    
    userSearchResults.classList.remove('hidden');
    userSearchLoading.classList.remove('hidden');
    userSearchEmpty.classList.add('hidden');
    userSearchList.innerHTML = '';

    try {
      console.log('Fetching users from API...');
      const response = await fetch(`/api/search-users?q=${encodeURIComponent(query)}`);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log('Search response:', data);

      userSearchLoading.classList.add('hidden');

      if (data.users && data.users.length > 0) {
        console.log('Found', data.users.length, 'users');
        userSearchEmpty.classList.add('hidden');
        
        data.users.forEach(user => {
          const userItem = document.createElement('button');
          userItem.type = 'button';
          userItem.className = 'w-full flex items-center gap-3 px-4 py-3 hover:bg-stone-100 dark:hover:bg-stone-700 transition-colors text-left rounded-lg mx-2';
          userItem.innerHTML = `
            <img src="${user.avatar}" alt="${user.displayName}" class="w-8 h-8 rounded-xl object-cover border border-stone-300 dark:border-stone-600" />
            <div class="flex-1 min-w-0">
              <div class="font-medium text-stone-800 dark:text-stone-200 truncate">${user.displayName}</div>
              <div class="text-xs text-stone-600 dark:text-stone-400 truncate">@${user.username}</div>
            </div>
          `;
          
          userItem.addEventListener('click', () => {
            selectUser(user);
          });
          
          userSearchList.appendChild(userItem);
        });
      } else {
        console.log('No users found');
        userSearchEmpty.classList.remove('hidden');
      }
    } catch (error) {
      console.error('User search error:', error);
      userSearchLoading.classList.add('hidden');
      userSearchEmpty.classList.remove('hidden');
      userSearchEmpty.textContent = 'Search failed. Please try again.';
    }
  }

  // Select user
  function selectUser(user) {
    selectedUserId = user.id;
    selectedUserAvatar.src = user.avatar;
    selectedUserName.textContent = user.displayName;
    selectedUserUsername.textContent = `@${user.username}`;
    
    selectedUser.classList.remove('hidden');
    userSearchResults.classList.add('hidden');
    userSearchInput.value = '';
    messageInput.focus();
  }

  // Remove selected user
  removeSelectedUserBtn?.addEventListener('click', () => {
    selectedUserId = null;
    selectedUser.classList.add('hidden');
    userSearchInput.focus();
  });

  // Send message
  sendMessageBtn?.addEventListener('click', async () => {
    if (!selectedUserId || !messageInput.value.trim()) {
      alert('Please select a user and enter a message.');
      return;
    }

    sendMessageBtn.disabled = true;
    sendMessageBtn.textContent = 'Sending...';

    try {
      // Prepare request body
      let requestBody = {
        target_user_id: selectedUserId,
        initial_message: messageInput.value.trim()
      };

      // Try to encrypt the message if auto encryption is available
      if (autoEncryption && autoEncryption.isReady()) {
        try {
          const encryptedData = await autoEncryption.encryptMessageForUser(
            messageInput.value.trim(), 
            selectedUserId
          );
          requestBody.encrypted_content = encryptedData;
        } catch (encryptError) {
          console.error('Encryption failed, sending unencrypted:', encryptError);
          // Continue with unencrypted message
        }
      }

      // Create conversation
      const response = await fetch('/api/create-conversation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      let data;
      try {
        data = await response.json();
      } catch (jsonError) {
        // If response is not JSON, get text instead
        const responseText = await response.text();
        console.error('Non-JSON response:', responseText);
        throw new Error(`Server returned non-JSON response: ${responseText.substring(0, 100)}...`);
      }

      if (response.ok) {
        // Redirect to the new conversation
        window.location.href = `/inbox/${data.conversation_id}`;
      } else {
        console.error('Create conversation API error:', {
          status: response.status,
          statusText: response.statusText,
          data: data
        });
        
        let errorMessage = data.error || 'Failed to create conversation';
        if (data.code) {
          errorMessage += ` (${data.code})`;
        }
        if (data.details) {
          console.error('Error details:', data.details);
          errorMessage += `\n\nDetails: ${data.details}`;
        }
        
        throw new Error(errorMessage);
      }
    } catch (error) {
      console.error('Error creating conversation:', error);
      alert('Failed to send message: ' + error.message);
      
      sendMessageBtn.disabled = false;
      sendMessageBtn.textContent = 'Send Message';
    }
  });

  // Close modal when clicking outside
  newMessageModal?.addEventListener('click', (e) => {
    if (e.target === newMessageModal) {
      closeModal();
    }
  });
  } // End of initializeInbox function
</script>

<style>
  /* Smooth animations */
  .conversation-item {
    animation: fadeInUp 0.4s ease-out forwards;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Stagger animation */
  .conversation-item:nth-child(1) { animation-delay: 0s; }
  .conversation-item:nth-child(2) { animation-delay: 0.1s; }
  .conversation-item:nth-child(3) { animation-delay: 0.2s; }
  .conversation-item:nth-child(4) { animation-delay: 0.3s; }
  .conversation-item:nth-child(5) { animation-delay: 0.4s; }

  /* Modal animation */
  .animate-fade-in-up {
    animation: fadeInUp 0.3s ease-out forwards;
  }
</style>