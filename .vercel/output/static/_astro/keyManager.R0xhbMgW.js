class u{constructor(){this.keyPair=null,this.publicKey=null,this.privateKey=null}async generateKeyPair(){try{return this.keyPair=await window.crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!0,["encrypt","decrypt"]),this.publicKey=this.keyPair.publicKey,this.privateKey=this.keyPair.privateKey,{publicKey:await this.exportPublicKey(),privateKey:await this.exportPrivateKey()}}catch(r){throw console.error("Error generating key pair:",r),new Error("Failed to generate encryption keys")}}async exportPublicKey(){if(!this.publicKey)throw new Error("No public key available");const r=await window.crypto.subtle.exportKey("spki",this.publicKey);return this.arrayBufferToBase64(r)}async exportPrivateKey(){if(!this.privateKey)throw new Error("No private key available");const r=await window.crypto.subtle.exportKey("pkcs8",this.privateKey);return this.arrayBufferToBase64(r)}async importPublicKey(r){try{const e=this.base64ToArrayBuffer(r);return await window.crypto.subtle.importKey("spki",e,{name:"RSA-OAEP",hash:"SHA-256"},!1,["encrypt"])}catch(e){throw console.error("Error importing public key:",e),new Error("Failed to import public key")}}async importPrivateKey(r){try{const e=this.base64ToArrayBuffer(r);return this.privateKey=await window.crypto.subtle.importKey("pkcs8",e,{name:"RSA-OAEP",hash:"SHA-256"},!1,["decrypt"]),this.privateKey}catch(e){throw console.error("Error importing private key:",e),new Error("Failed to import private key")}}async encryptMessage(r,e){try{const t=await window.crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),s=window.crypto.getRandomValues(new Uint8Array(12)),i=new TextEncoder().encode(r),n=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:s},t,i),o=await window.crypto.subtle.exportKey("raw",t),a=await this.importPublicKey(e),c=await window.crypto.subtle.encrypt({name:"RSA-OAEP"},a,o);return{encryptedMessage:this.arrayBufferToBase64(n),encryptedKey:this.arrayBufferToBase64(c),iv:this.arrayBufferToBase64(s),algorithm:"AES-GCM-RSA-OAEP"}}catch(t){throw console.error("Error encrypting message:",t),new Error("Failed to encrypt message")}}async decryptMessage(r){try{if(!this.privateKey)throw new Error("Private key not loaded");const{encryptedMessage:e,encryptedKey:t,iv:s,algorithm:i}=r;if(i!=="AES-GCM-RSA-OAEP")throw new Error("Unsupported encryption algorithm");const n=this.base64ToArrayBuffer(t),o=await window.crypto.subtle.decrypt({name:"RSA-OAEP"},this.privateKey,n),a=await window.crypto.subtle.importKey("raw",o,{name:"AES-GCM"},!1,["decrypt"]),c=this.base64ToArrayBuffer(e),p=this.base64ToArrayBuffer(s),h=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:p},a,c);return new TextDecoder().decode(h)}catch(e){throw console.error("Error decrypting message:",e),new Error("Failed to decrypt message")}}async deriveKeyFromPassword(r,e){const s=new TextEncoder().encode(r),i=await window.crypto.subtle.importKey("raw",s,"PBKDF2",!1,["deriveKey"]);return await window.crypto.subtle.deriveKey({name:"PBKDF2",salt:e,iterations:1e5,hash:"SHA-256"},i,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async encryptPrivateKeyWithPassword(r,e){try{const t=window.crypto.getRandomValues(new Uint8Array(16)),s=window.crypto.getRandomValues(new Uint8Array(12)),i=await this.deriveKeyFromPassword(e,t),n=new TextEncoder().encode(r),o=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:s},i,n);return{encryptedPrivateKey:this.arrayBufferToBase64(o),salt:this.arrayBufferToBase64(t),iv:this.arrayBufferToBase64(s)}}catch(t){throw console.error("Error encrypting private key:",t),new Error("Failed to encrypt private key")}}async decryptPrivateKeyWithPassword(r,e){try{const{encryptedPrivateKey:t,salt:s,iv:i}=r,n=this.base64ToArrayBuffer(s),o=this.base64ToArrayBuffer(i),a=this.base64ToArrayBuffer(t),c=await this.deriveKeyFromPassword(e,n),p=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:o},c,a);return new TextDecoder().decode(p)}catch(t){throw console.error("Error decrypting private key:",t),new Error("Failed to decrypt private key - wrong password?")}}arrayBufferToBase64(r){const e=new Uint8Array(r);let t="";for(let s=0;s<e.byteLength;s++)t+=String.fromCharCode(e[s]);return btoa(t)}base64ToArrayBuffer(r){const e=atob(r),t=new Uint8Array(e.length);for(let s=0;s<e.length;s++)t[s]=e.charCodeAt(s);return t.buffer}generateSecurePassword(r=32){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*",t=new Uint8Array(r);window.crypto.getRandomValues(t);let s="";for(let i=0;i<r;i++)s+=e[t[i]%e.length];return s}}class w{constructor(){this.encryption=new u,this.isUnlocked=!1,this.sessionTimeout=1800*1e3,this.sessionTimer=null}async initializeUserEncryption(r,e){try{const t=await this.encryption.generateKeyPair(),s=await this.encryption.encryptPrivateKeyWithPassword(t.privateKey,e),i={user_id:r,public_key:t.publicKey,encrypted_private_key:s.encryptedPrivateKey,key_salt:s.salt,key_iv:s.iv,created_at:new Date().toISOString()},n=await fetch("/api/encryption/store-keys",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(i)});if(!n.ok){const o=await n.json().catch(()=>({}));throw o.code==="TABLE_NOT_FOUND"?new Error("Database not configured for encryption. Please run the SQL migrations first."):new Error(o.message||"Failed to store encryption keys")}return await this.encryption.importPrivateKey(t.privateKey),this.isUnlocked=!0,this.startSessionTimer(),!0}catch(t){throw console.error("Error initializing user encryption:",t),t}}async unlockKeys(r,e){try{const t=await fetch(`/api/encryption/get-keys/${r}`);if(!t.ok)throw new Error("Failed to fetch encryption keys");const s=await t.json(),i={encryptedPrivateKey:s.encrypted_private_key,salt:s.key_salt,iv:s.key_iv},n=await this.encryption.decryptPrivateKeyWithPassword(i,e);return await this.encryption.importPrivateKey(n),this.isUnlocked=!0,this.startSessionTimer(),this.userPublicKey=s.public_key,!0}catch(t){throw console.error("Error unlocking keys:",t),new Error("Failed to unlock encryption keys - wrong password?")}}async getUserPublicKey(r){try{const e=await fetch(`/api/encryption/get-public-key/${r}`);if(!e.ok)throw new Error("Failed to fetch user public key");return(await e.json()).public_key}catch(e){throw console.error("Error fetching user public key:",e),e}}async encryptMessageForUser(r,e){if(!this.isUnlocked)throw new Error("Encryption keys are locked. Please unlock first.");try{const t=await this.getUserPublicKey(e);return await this.encryption.encryptMessage(r,t)}catch(t){throw console.error("Error encrypting message for user:",t),t}}async decryptMessage(r){if(!this.isUnlocked)throw new Error("Encryption keys are locked. Please unlock first.");try{return await this.encryption.decryptMessage(r)}catch(e){throw console.error("Error decrypting message:",e),e}}lockKeys(){this.encryption.privateKey=null,this.isUnlocked=!1,this.clearSessionTimer(),this.userPublicKey=null,console.log("Encryption keys locked")}startSessionTimer(){this.clearSessionTimer(),this.sessionTimer=setTimeout(()=>{this.lockKeys(),this.showSessionExpiredNotification()},this.sessionTimeout)}clearSessionTimer(){this.sessionTimer&&(clearTimeout(this.sessionTimer),this.sessionTimer=null)}extendSession(){this.isUnlocked&&this.startSessionTimer()}showSessionExpiredNotification(){typeof window<"u"&&window.showNotification&&window.showNotification("Your encryption session has expired. Please unlock your keys to continue messaging.","warning",1e4)}async hasEncryptionKeys(r){try{return(await(await fetch(`/api/encryption/check-keys/${r}`)).json()).hasKeys}catch(e){return console.error("Error checking encryption keys:",e),!1}}generateSecurePassword(){return this.encryption.generateSecurePassword()}validatePasswordStrength(r){const t=/[A-Z]/.test(r),s=/[a-z]/.test(r),i=/\d/.test(r),n=/[!@#$%^&*(),.?":{}|<>]/.test(r),o=[];return r.length<12&&o.push("Password must be at least 12 characters long"),t||o.push("Password must contain at least one uppercase letter"),s||o.push("Password must contain at least one lowercase letter"),i||o.push("Password must contain at least one number"),n||o.push("Password must contain at least one special character"),{isValid:o.length===0,issues:o,strength:this.calculatePasswordStrength(r)}}calculatePasswordStrength(r){let e=0;return e+=Math.min(r.length*2,20),/[a-z]/.test(r)&&(e+=5),/[A-Z]/.test(r)&&(e+=5),/\d/.test(r)&&(e+=5),/[!@#$%^&*(),.?":{}|<>]/.test(r)&&(e+=10),r.length>=16&&(e+=10),/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*])/.test(r)&&(e+=15),e>=70?"very-strong":e>=50?"strong":e>=30?"medium":e>=15?"weak":"very-weak"}}const d=new w;let l;function f(){clearTimeout(l),l=setTimeout(()=>{d.extendSession()},1e3)}typeof window<"u"&&["mousedown","mousemove","keypress","scroll","touchstart"].forEach(y=>{document.addEventListener(y,f,{passive:!0})});export{w as KeyManager,d as keyManager};
